"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = exports.CANNOT_MANAGE_TRASACTIONS_ERROR = void 0;
const ydb_sdk_proto_1 = require("ydb-sdk-proto");
const symbols = __importStar(require("./symbols"));
const build_async_queue_iterator_1 = require("../utils/build-async-queue-iterator");
const ResultSet_1 = require("./ResultSet");
const process_ydb_operation_result_1 = require("../utils/process-ydb-operation-result");
const long_1 = __importDefault(require("long"));
const errors_1 = require("../errors");
const query_session_1 = require("./query-session");
const types_1 = require("../types");
const symbols_1 = require("./symbols");
exports.CANNOT_MANAGE_TRASACTIONS_ERROR = 'Cannot manage transactions at the session level if do() has the txSettings parameter or doTx() is used';
/**
 * Finishes when the first data block is received or when the end of the stream is received. So if you are sure
 * that the operation does not return any data, you may not process resultSets.
 */
function execute(opts) {
    var _a, _b, _c, _d, _e, _f, _g;
    // Validate opts
    if (!opts.text.trim())
        throw new Error('"text" parameter is empty');
    if (opts.parameters)
        Object.keys(opts.parameters).forEach(n => {
            if (!n.startsWith('$'))
                throw new Error(`Parameter name must start with "$": ${n}`);
        });
    if (opts.txControl && this[symbols.sessionTxSettings])
        throw new Error(exports.CANNOT_MANAGE_TRASACTIONS_ERROR);
    if ((_a = opts.txControl) === null || _a === void 0 ? void 0 : _a.txId)
        throw new Error('Cannot contain txControl.txId because the current session transaction is used (see session.txId)');
    if (this[symbols.sessionTxId]) {
        if ((_b = opts.txControl) === null || _b === void 0 ? void 0 : _b.beginTx)
            throw new Error('txControl.beginTx when there\'s already an open transaction');
    }
    else {
        if (((_c = opts.txControl) === null || _c === void 0 ? void 0 : _c.commitTx) && !((_d = opts.txControl) === null || _d === void 0 ? void 0 : _d.beginTx))
            throw new Error('txControl.commitTx === true when no open transaction and there\'s no txControl.beginTx');
    }
    // Build params
    const executeQueryRequest = {
        sessionId: this.sessionId,
        queryContent: {
            text: opts.text,
            syntax: (_e = opts.syntax) !== null && _e !== void 0 ? _e : ydb_sdk_proto_1.Ydb.Query.Syntax.SYNTAX_YQL_V1,
        },
        execMode: (_f = opts.execMode) !== null && _f !== void 0 ? _f : ydb_sdk_proto_1.Ydb.Query.ExecMode.EXEC_MODE_EXECUTE,
    };
    if (opts.statsMode)
        executeQueryRequest.statsMode = opts.statsMode;
    if (opts.parameters)
        executeQueryRequest.parameters = opts.parameters;
    if (this[symbols.sessionTxSettings] && !this[symbols.sessionTxId])
        executeQueryRequest.txControl = { beginTx: this[symbols.sessionTxSettings], commitTx: false };
    else if (opts.txControl)
        executeQueryRequest.txControl = opts.txControl;
    if (this[symbols.sessionTxId])
        (executeQueryRequest.txControl || (executeQueryRequest.txControl = {})).txId = this[symbols.sessionTxId];
    executeQueryRequest.concurrentResultSets = (_g = opts.concurrentResultSets) !== null && _g !== void 0 ? _g : false;
    // Run the operation
    let finished = false;
    const resultSetByIndex = [];
    const resultSetIterator = (0, build_async_queue_iterator_1.buildAsyncQueueIterator)();
    const concurrentResultSets = executeQueryRequest.concurrentResultSets;
    let lastRowsIterator;
    let resultResolve;
    let resultReject;
    let finishedResolve;
    let finishedReject;
    let responseStream;
    let execStats;
    // Timeout if any
    // TODO: Change to ctx.withTimout once Context will be finished
    const timeoutTimer = typeof opts.timeout === 'number' && opts.timeout > 0 ?
        setTimeout(() => {
            cancel(new Error('Timeout is over'));
        }, opts.timeout)
        : undefined;
    // One operation per session in a time. And it might be cancelled
    if (this[symbols.sessionCurrentOperation])
        throw new Error('There\'s another active operation in the session');
    const cancel = (reason, onStreamError) => {
        if (finished)
            return;
        finished = true;
        if (onStreamError !== true)
            responseStream.cancel();
        if (timeoutTimer)
            clearTimeout(timeoutTimer);
        if (resultReject) {
            resultReject(reason);
            resultResolve = resultReject = undefined;
        }
        else { // resultSet has already been returned to a client code
            resultSetIterator.error(reason);
            Object.values(resultSetByIndex).forEach(([iterator]) => {
                iterator.error(reason);
            });
        }
        if (finishedReject)
            finishedReject(reason);
        delete this[symbols.sessionCurrentOperation];
    };
    this[symbols.sessionCurrentOperation] = { cancel };
    // Operation
    responseStream = this[query_session_1.impl].grpcClient.makeServerStreamRequest("/Ydb.Query.V1.QueryService/ExecuteQuery" /* Query_V1.ExecuteQuery */, (v) => ydb_sdk_proto_1.Ydb.Query.ExecuteQueryRequest.encode(v).finish(), ydb_sdk_proto_1.Ydb.Query.ExecuteQueryResponsePart.decode, ydb_sdk_proto_1.Ydb.Query.ExecuteQueryRequest.create(executeQueryRequest), this[query_session_1.impl].metadata);
    responseStream.on('data', (partialResp) => {
        var _a, _b, _c, _d;
        this.logger.trace('execute(): data: %o', partialResp);
        try {
            (0, process_ydb_operation_result_1.ensureCallSucceeded)(partialResp);
        }
        catch (ydbErr) {
            return cancel(ydbErr);
        }
        if ((_a = partialResp.txMeta) === null || _a === void 0 ? void 0 : _a.id)
            this[symbols.sessionTxId] = partialResp.txMeta.id;
        else
            delete this[symbols.sessionTxId];
        if (partialResp.resultSet) {
            const _index = partialResp.resultSetIndex;
            const index = long_1.default.isLong(_index) ? _index.toInt() : resultSetByIndex;
            let iterator;
            let resultSet;
            let resultSetTuple = resultSetByIndex[index];
            if (!resultSetTuple) {
                iterator = (0, build_async_queue_iterator_1.buildAsyncQueueIterator)();
                switch (opts.rowMode) {
                    case 1 /* RowType.Ydb */:
                        resultSet = new ResultSet_1.ResultSet(index, partialResp.resultSet.columns, (_b = opts.rowMode) !== null && _b !== void 0 ? _b : 0 /* RowType.Native */, iterator);
                        break;
                    default: // Native
                        const nativeColumnsNames = partialResp.resultSet.columns.map(v => types_1.snakeToCamelCaseConversion.ydbToJs(v.name));
                        resultSet = new ResultSet_1.ResultSet(index, nativeColumnsNames, (_c = opts.rowMode) !== null && _c !== void 0 ? _c : 0 /* RowType.Native */, iterator);
                        resultSet[symbols_1.resultsetYdbColumns] = partialResp.resultSet.columns;
                }
                resultSetIterator.push(resultSet);
                resultSetByIndex[index] = [iterator, resultSet];
                if (!concurrentResultSets) {
                    lastRowsIterator === null || lastRowsIterator === void 0 ? void 0 : lastRowsIterator.end();
                    lastRowsIterator = iterator;
                }
            }
            else {
                [iterator, resultSet] = resultSetTuple;
            }
            switch (opts.rowMode) {
                case 1 /* RowType.Ydb */:
                    for (const row of partialResp.resultSet.rows)
                        iterator.push(row);
                    break;
                default: // Native
                    for (const row of partialResp.resultSet.rows) {
                        // TODO: Rewrite to reduce
                        const nativeRow = {}; // reduced was not used due some strange typing behaviour
                        try {
                            (_d = row.items) === null || _d === void 0 ? void 0 : _d.forEach((v, i) => {
                                const nativeColumnName = resultSet.columns[i];
                                nativeRow[nativeColumnName] = (0, types_1.convertYdbValueToNative)(resultSet[symbols_1.resultsetYdbColumns][i].type, v);
                            });
                        }
                        catch (err) {
                            throw err;
                        }
                        iterator.push(nativeRow);
                    }
            }
            if (resultResolve) {
                resultResolve({
                    resultSets: resultSetIterator[Symbol.asyncIterator](), // a list with first block already in it
                    get execStats() {
                        return execStats;
                    },
                    opFinished: new Promise((resolve, reject) => {
                        finishedResolve = resolve;
                        finishedReject = reject;
                    })
                });
                resultResolve = resultReject = undefined;
            }
        }
        if (partialResp.execStats) {
            execStats = partialResp.execStats;
        }
        partialResp.txMeta;
    });
    responseStream.on('error', (err) => {
        this.logger.trace('execute(): error: %o', err);
        if (err.code === 1)
            return; // skip "cancelled" error
        cancel(errors_1.TransportError.convertToYdbError(err), true);
    });
    responseStream.on('metadata', (_metadata) => {
        // TODO: Process partial meta
        // TODO: Expect to see on graceful shutdown
    });
    responseStream.on('end', () => {
        if (finished)
            return; // finished by cancel() - error or timeout. note: got to be before any logging, so Jest would not complain on logging after test end
        this.logger.trace('execute(): end');
        resultSetIterator.end();
        if (concurrentResultSets) {
            Object.values(resultSetByIndex).forEach(([iterator]) => {
                iterator.end();
            });
        }
        else {
            lastRowsIterator === null || lastRowsIterator === void 0 ? void 0 : lastRowsIterator.end();
        }
        if (resultResolve) {
            resultResolve({
                resultSets: resultSetIterator[Symbol.asyncIterator](), // an empty list
                get execStats() {
                    return execStats;
                },
                opFinished: Promise.resolve()
            });
            resultResolve = resultReject = undefined;
        }
        if (finishedResolve)
            finishedResolve();
        delete this[symbols.sessionCurrentOperation];
        finished = true;
    });
    return new Promise((resolve, reject) => {
        resultResolve = resolve;
        resultReject = reject;
    });
}
exports.execute = execute;
