"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuerySessionPool = exports.SessionEvent = exports.SessionBuilder = exports.QueryService = void 0;
const ydb_sdk_proto_1 = require("ydb-sdk-proto");
exports.QueryService = ydb_sdk_proto_1.Ydb.Query.V1.QueryService;
var CreateSessionRequest = ydb_sdk_proto_1.Ydb.Query.CreateSessionRequest;
const retries_1 = require("../retries");
const events_1 = __importDefault(require("events"));
const constants_1 = require("../constants");
const lodash_1 = __importDefault(require("lodash"));
const errors_1 = require("../errors");
const query_session_1 = require("./query-session");
const utils_1 = require("../utils");
const process_ydb_operation_result_1 = require("../utils/process-ydb-operation-result");
const utils_2 = require("../utils");
const symbols = __importStar(require("./symbols"));
class SessionBuilder extends utils_2.AuthenticatedService {
    constructor(endpoint, database, authService, logger, sslCredentials, clientOptions) {
        const host = endpoint.toString();
        super(host, database, 'Ydb.Query.V1.QueryService', exports.QueryService, authService, sslCredentials, clientOptions, ['AttachSession', 'ExecuteQuery'] // methods that return Stream
        );
        this.endpoint = endpoint;
        this.logger = logger;
    }
    async create() {
        const { sessionId } = (0, process_ydb_operation_result_1.ensureCallSucceeded)(await this.api.createSession(CreateSessionRequest.create()));
        const session = query_session_1.QuerySession[symbols.create](this.api, this, this.endpoint, sessionId, this.logger /*, this.getResponseMetadata.bind(this)*/);
        await session[symbols.sessionAttach](() => { session[symbols.sessionDeleteOnRelease](); });
        return session;
    }
}
exports.SessionBuilder = SessionBuilder;
__decorate([
    (0, retries_1.retryable)(),
    utils_1.pessimizable
], SessionBuilder.prototype, "create", null);
var SessionEvent;
(function (SessionEvent) {
    SessionEvent["SESSION_RELEASE"] = "SESSION_RELEASE";
    SessionEvent["SESSION_BROKEN"] = "SESSION_BROKEN";
})(SessionEvent || (exports.SessionEvent = SessionEvent = {}));
class QuerySessionPool extends events_1.default {
    constructor(settings) {
        super();
        this.waiters = [];
        this.database = settings.database;
        this.authService = settings.authService;
        this.sslCredentials = settings.sslCredentials;
        this.clientOptions = settings.clientOptions;
        this.logger = settings.logger;
        const poolSettings = settings.poolSettings;
        this.minLimit = (poolSettings === null || poolSettings === void 0 ? void 0 : poolSettings.minLimit) || QuerySessionPool.SESSION_MIN_LIMIT;
        this.maxLimit = (poolSettings === null || poolSettings === void 0 ? void 0 : poolSettings.maxLimit) || QuerySessionPool.SESSION_MAX_LIMIT;
        this.sessions = new Set();
        this.newSessionsRequested = 0;
        this.sessionsBeingDeleted = 0;
        this.sessionBuilders = new Map();
        this.discoveryService = settings.discoveryService;
        this.discoveryService.on(constants_1.Events.ENDPOINT_REMOVED, (endpoint) => {
            this.sessionBuilders.delete(endpoint);
        });
        // this.prepopulateSessions();
    }
    async destroy() {
        this.logger.debug('Destroying query pool...');
        await Promise.all(lodash_1.default.map([...this.sessions], (session) => this.deleteSession(session)));
        this.logger.debug('Query pool has been destroyed.');
    }
    // TODO: Uncomment after switch to TS 5.3
    // [Symbol.asyncDispose]() {
    //     return this.destroy();
    // }
    // TODO: Reconsider. Seems like bad idea for serverless functions and causes problems on quick dispose
    // private prepopulateSessions() {
    //     _.forEach(_.range(this.minLimit), () => this.createSession());
    // }
    async getSessionBuilder() {
        const endpoint = await this.discoveryService.getEndpoint();
        if (!this.sessionBuilders.has(endpoint)) {
            const sessionService = new SessionBuilder(endpoint, this.database, this.authService, this.logger, this.sslCredentials, this.clientOptions);
            this.sessionBuilders.set(endpoint, sessionService);
        }
        return this.sessionBuilders.get(endpoint);
    }
    maybeUseSession(session) {
        if (this.waiters.length > 0) {
            const waiter = this.waiters.shift();
            if (typeof waiter === "function") {
                waiter(session);
                return true;
            }
        }
        return false;
    }
    async createSession() {
        const sessionCreator = await this.getSessionBuilder();
        const session = await sessionCreator.create();
        session.on(SessionEvent.SESSION_RELEASE, async () => {
            if (session[symbols.sessionIsClosing]()) {
                await this.deleteSession(session);
            }
            else {
                this.maybeUseSession(session);
            }
        });
        session.on(SessionEvent.SESSION_BROKEN, async () => {
            await this.deleteSession(session);
        });
        this.sessions.add(session);
        return session;
    }
    deleteSession(session) {
        if (session[symbols.sessionIsDeleted]()) {
            return Promise.resolve();
        }
        this.sessionsBeingDeleted++;
        // acquire new session as soon one of existing ones is deleted
        if (this.waiters.length > 0) {
            this.acquire().then((session) => {
                if (!this.maybeUseSession(session)) {
                    session[symbols.sessionRelease]();
                }
            });
        }
        return session.delete()
            // delete session in any case
            .finally(() => {
            this.sessions.delete(session);
            this.sessionsBeingDeleted--;
        });
    }
    acquire(timeout = 0) {
        for (const session of this.sessions) {
            if (session[symbols.sessionIsFree]()) {
                return Promise.resolve(session[symbols.sessionAcquire]());
            }
        }
        if (this.sessions.size + this.newSessionsRequested - this.sessionsBeingDeleted <= this.maxLimit) {
            this.newSessionsRequested++;
            return this.createSession()
                .then((session) => {
                return session[symbols.sessionAcquire]();
            })
                .finally(() => {
                this.newSessionsRequested--;
            });
        }
        else {
            return new Promise((resolve, reject) => {
                let timeoutId;
                function waiter(session) {
                    clearTimeout(timeoutId);
                    resolve(session[symbols.sessionAcquire]());
                }
                if (timeout) {
                    timeoutId = setTimeout(() => {
                        this.waiters.splice(this.waiters.indexOf(waiter), 1);
                        reject(new errors_1.SessionPoolEmpty(`No session became available within timeout of ${timeout} ms`));
                    }, timeout);
                }
                this.waiters.push(waiter);
            });
        }
    }
}
exports.QuerySessionPool = QuerySessionPool;
QuerySessionPool.SESSION_MIN_LIMIT = 5;
QuerySessionPool.SESSION_MAX_LIMIT = 20;
